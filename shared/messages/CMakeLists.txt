# This directory contains our message types and other shared types
INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/shared/)

# We need protobuf and python
FIND_PACKAGE(Protobuf REQUIRED)
FIND_PACKAGE(PythonInterp REQUIRED)

# Get all of our messages
FILE(GLOB_RECURSE protobufs "**.proto")

FOREACH(proto ${protobufs})

    # Get the file without the extension
    GET_FILENAME_COMPONENT(file_we ${proto} NAME_WE)

    # Calculate the Output Directory
    FILE(RELATIVE_PATH outputpath ${CMAKE_CURRENT_SOURCE_DIR} ${proto})
    GET_FILENAME_COMPONENT(outputpath ${outputpath} PATH)
    SET(outputpath "${CMAKE_CURRENT_BINARY_DIR}/${outputpath}")

    # Get the dependencies on this protobuf so we can recompile on changes
    # If they change you will need to re cmake
    EXECUTE_PROCESS(COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}
                            --dependency_out=${CMAKE_CURRENT_BINARY_DIR}/temp1
                            --descriptor_set_out=${CMAKE_CURRENT_BINARY_DIR}/temp2
                            -I${CMAKE_SOURCE_DIR}/shared
                            ${proto})
    FILE(READ "${CMAKE_CURRENT_BINARY_DIR}/temp1" dependencies)
    STRING(REGEX REPLACE "\\\\\n" ";" dependencies ${dependencies})
    FILE(REMOVE "${CMAKE_CURRENT_BINARY_DIR}/temp1" "${CMAKE_CURRENT_BINARY_DIR}/temp2")

    # Clean our dependency list
    FOREACH(depend ${dependencies})
        STRING(STRIP ${depend} depend)
        FILE(RELATIVE_PATH depend_rel ${CMAKE_CURRENT_SOURCE_DIR} ${depend})

        # Absolute dependencies
        IF(depend_rel MATCHES "^\\.\\.")
            SET(source_depends ${source_depends} ${depend})
            SET(binary_depends ${binary_depends} ${depend})
        # Relative dependencies
        ELSE()
            SET(source_depends ${source_depends} "${CMAKE_CURRENT_SOURCE_DIR}/${depend_rel}")
            SET(binary_depends ${binary_depends} "${CMAKE_CURRENT_BINARY_DIR}/${depend_rel}")
        ENDIF()
    ENDFOREACH()

    # Extract the protocol buffer information so we can generate code off it
    ADD_CUSTOM_COMMAND(
        OUTPUT "${outputpath}/${file_we}.pb"
        COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}
        ARGS --descriptor_set_out "${outputpath}/${file_we}.pb"
             -I ${CMAKE_SOURCE_DIR}/shared
             ${proto}
        DEPENDS ${source_depends}
        COMMENT "Extracting protocol buffer information from ${proto}")

    # Repackage our protocol buffers so they don't collide with the actual classes
    # when we make our c++ protobuf classes by adding protobuf to the package
    ADD_CUSTOM_COMMAND(
        OUTPUT "${outputpath}/${file_we}.proto"
        COMMAND ${PYTHON_EXECUTABLE}
        ARGS "${CMAKE_SOURCE_DIR}/tools/scripts/repackage_message.py" ${proto} ${outputpath}
        DEPENDS "${CMAKE_SOURCE_DIR}/tools/scripts/repackage_message.py"
                ${source_depends}
        COMMENT "Repackaging protobuf ${proto}")

    # Run the protocol buffer compiler on these new protobufs
    ADD_CUSTOM_COMMAND(
        OUTPUT "${outputpath}/${file_we}.pb.cc"
               "${outputpath}/${file_we}.pb.h"
               "${outputpath}/${file_we}_pb2.py"
        COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}
        ARGS --cpp_out ${CMAKE_BINARY_DIR}/shared
             --python_out ${CMAKE_BINARY_DIR}/shared
             -I ${CMAKE_BINARY_DIR}/shared
             "${outputpath}/${file_we}.proto"
        DEPENDS ${binary_depends}
        COMMENT "Compiling protocol buffer ${proto}")

    # Build our c++ class from the extracted information
    ADD_CUSTOM_COMMAND(
        OUTPUT "${outputpath}/${file_we}.cpp"
               "${outputpath}/${file_we}.h"
        COMMAND ${PYTHON_EXECUTABLE}
        ARGS "${CMAKE_SOURCE_DIR}/tools/scripts/build_message_class.py" "${outputpath}/${file_we}" ${outputpath}
        WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}"
        DEPENDS "${CMAKE_SOURCE_DIR}/tools/scripts/build_message_class.py"
                "${CMAKE_CURRENT_BINARY_DIR}/MessageOptions_pb2.py"
                "${outputpath}/${file_we}.pb"
        COMMENT "Building classes for ${proto}")

    # The protobuf descriptions are generated
    SET_SOURCE_FILES_PROPERTIES("${outputpath}/${file_we}.pb"
                                "${outputpath}/${file_we}.proto"
                                "${outputpath}/${file_we}.pb.cc"
                                "${outputpath}/${file_we}.pb.h"
                                "${outputpath}/${file_we}.cpp"
                                "${outputpath}/${file_we}.h"
                                 PROPERTIES GENERATED TRUE)

    # Add the generated files to our list
    SET(src ${src}
            "${outputpath}/${file_we}.pb.cc"
            "${outputpath}/${file_we}.pb.h"
            "${outputpath}/${file_we}.cpp"
            "${outputpath}/${file_we}.h")

ENDFOREACH(proto)

# Build a library from these files
ADD_LIBRARY(messages ${protobufs} ${src})

# Put it in an IDE group for shared
SET_PROPERTY(TARGET messages PROPERTY FOLDER "shared/")